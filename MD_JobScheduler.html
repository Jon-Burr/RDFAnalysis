<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RDFAnalysis: The Job Scheduler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RDFAnalysis
   &#160;<span id="projectnumber">0.1.1</span>
   </div>
   <div id="projectbrief">Physics analysis with ROOT::RDataFrame</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('MD_JobScheduler.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">The Job Scheduler </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#Scheduler_Introduction">Introduction</a></li>
<li><a href="#Scheduler_Concepts">Scheduler Concepts</a><ul>
<li><a href="#Scheduler_Actions">Actions and dependencies</a></li>
<li><a href="#Scheduler_Costs">Costs</a></li>
<li><a href="#Scheduler_FilterSatisfaction">Filter Satisfaction</a></li>
</ul>
</li>
<li><a href="#Scheduler_Usage">Usage Example</a></li>
<li><a href="#Schedule_AdvancedExample">Advanced Example</a></li>
<li><a href="#Scheduler_Notes">Important notes and caveats</a></li>
</ul>
<h1><a class="anchor" id="Scheduler_Introduction"></a>
Introduction</h1>
<p>Most users when designing an analysis do not generally care too much about the order in which variables are defined or how to merge the definitions of their various regions into a tree structure. Instead, what you usually wish to have is a set of different regions (defined by selections on the dataset) and histograms (or similar) filled from within each of those regions. The <a class="el" href="classRDFAnalysis_1_1Scheduler.html">Scheduler</a> is built around these assumptions.</p>
<p>Rather than explicitly building the tree structure through <a class="el" href="classRDFAnalysis_1_1Node.html#ac115944ed7019695d9b89153a3e60304">Define</a> and <a class="el" href="classRDFAnalysis_1_1Node.html#a3e7e2e24d9c328a253249ea7e0a8d1a0">Filter</a> calls, and adding histograms through <a class="el" href="classRDFAnalysis_1_1NodeBase.html#a84b2edf02f47768c1a29ca2f384ff27e">Fill</a> calls, with the scheduler you instead tell it about all variables, filters and fills you want to use using the <a class="el" href="classRDFAnalysis_1_1Scheduler.html#a6a84d7356d031b32950eb3c164d46695">registerVariable</a>, <a class="el" href="classRDFAnalysis_1_1Scheduler.html#aaf8f93e52ef9d818643c6e1accb31f4b">registerFilter</a> and <a class="el" href="classRDFAnalysis_1_1Scheduler.html#a043b772b2f4b0f687e66a2c902ffd3a2">registerFill</a> functions. Then, you define new regions using the <a class="el" href="classRDFAnalysis_1_1SchedulerBase.html#a64153b40c073b57fee34777accbf3061">addRegion</a> function and add fills to those regions using the <a class="el" href="structRDFAnalysis_1_1SchedulerBase_1_1RegionDef.html#a335af495fbd8d917c5a8856da6a9c431">addFill</a> function. Finally, you schedule the full computational graph using the <a class="el" href="classRDFAnalysis_1_1Scheduler.html#a8f5f319ec07b248d2c8dcc273f59f127">schedule</a> function.</p>
<p>The output writer can <a class="el" href="classRDFAnalysis_1_1OutputWriter.html#a8f01c1580db15d864e6837590cb23b0c">write from a Scheduler</a> directly. When doing this, rather than the nested tree structure used before each region will be written to a separated directory.</p>
<p>The scheduling works in three phases. First a 'raw' schedule is constructed that merges together all the region definitions into a single tree. Then, the <a class="el" href="classRDFAnalysis_1_1Scheduler.html">Scheduler</a> calculates the necessary order in which to insert any <a href="#Scheduler_Actions">dependencies</a> before each point in the raw schedule. Finally, the scheduler performs the corresponding <a class="el" href="classRDFAnalysis_1_1Node.html#ac115944ed7019695d9b89153a3e60304">Define</a>, <a class="el" href="classRDFAnalysis_1_1Node.html#a3e7e2e24d9c328a253249ea7e0a8d1a0">Filter</a> and <a class="el" href="classRDFAnalysis_1_1NodeBase.html#a84b2edf02f47768c1a29ca2f384ff27e">Fill</a> calls following the calculated graph.</p>
<p>Note that due to the lazy nature of RDataFrame Define calls, all variables are scheduled at the very start of the graph. Anything that depends on a variable then acquires all of that variable's dependencies. This ensures no variable is evaluated on an event where it is not valid.</p>
<h1><a class="anchor" id="Scheduler_Concepts"></a>
Scheduler Concepts</h1>
<h2><a class="anchor" id="Scheduler_Actions"></a>
Actions and dependencies</h2>
<p>When building the computational graph the <a class="el" href="classRDFAnalysis_1_1Scheduler.html">Scheduler</a> considers all defined variables, filters and fills together. We call these things 'Actions' (not to be confused with what ROOT::RDF::RNode terms Actions), represented by the <a class="el" href="structRDFAnalysis_1_1SchedulerBase_1_1Action.html" title="Helper struct to represent all the information that the scheduler needs to know about an action in or...">RDFAnalysis::SchedulerBase::Action</a> class.</p>
<p>Each action has a list of dependencies - these are the variables used as inputs to the operation and any selections necessary to make them valid. For instance the calculation "m_ee = (Electrons.at(0)+Electrons.at(1)).M()" depends on the 'Electrons' variable and some selection that ensures that there are at least two electrons. Each action has both direct dependencies like these but also indirect dependencies (each dependency's own direct dependencies). The variable dependencies can usually be deduced from the structure of the call and filter dependencies are specified as extra argument at the end of the call.</p>
<p>When building the computational graph the scheduler will add all dependencies of a particular action in before it. This allows easy creation of a histogram with preselections, just by listing the preselection as a filter dependency.</p>
<h2><a class="anchor" id="Scheduler_Costs"></a>
Costs</h2>
<p>Costs allow slightly more control over the order in which actions are scheduled. Lower cost actions will be scheduled earlier than higher cost actions. This can be used to fine-tune the output schedule. Normally this will not be too necessary.</p>
<h2><a class="anchor" id="Scheduler_FilterSatisfaction"></a>
Filter Satisfaction</h2>
<p>One subtlety involved in job scheduling is that filters are often not independent - one filter can satisfy another. For example, the selection x == 4 clearly satisfies the selection x &gt; 2. At best, scheduling x &gt; 2 after x == 4 wastes CPU time. At worst (when weights are involved) it can result in the double-counting of scale factors.</p>
<p>You can indicate to the scheduler that one filter satisfies another using the <a class="el" href="classRDFAnalysis_1_1SchedulerBase.html#ae5e3ece65cfe93368a40e340a49dc76d">filterSatisfies</a> function. Note that these satisfaction relations are transitive: if A satisfies B and B satisfies C then the scheduler will work out that A also satisfies C. More detail is provided in the <a href="#Schedule_AdvancedExample">advanced example</a>.</p>
<h1><a class="anchor" id="Scheduler_Usage"></a>
Usage Example</h1>
<p>Returning to the same example used before, this would be set up using the scheduler as</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> node_t = <a class="code" href="classRDFAnalysis_1_1Node.html">RDFAnalysis::Node&lt;CutflowDetail&gt;</a>;</div><div class="line"><span class="keyword">using</span> scheduler_t = <a class="code" href="classRDFAnalysis_1_1Scheduler.html">RDFAnalysis::Scheduler&lt;node_t::detail_t&gt;</a>;</div><div class="line"></div><div class="line">std::unique_ptr&lt;node_t&gt; root = node_t::createROOT(</div><div class="line">    inputDF, <span class="comment">//&gt; The input to this analysis</span></div><div class="line">    std::make_unique&lt;RDFAnalysis::DefaultBranchNamer&gt;({<span class="stringliteral">&quot;NOSYS&quot;</span>}), <span class="comment">//&gt; Systematics related</span></div><div class="line">    <span class="keyword">false</span> <span class="comment">//&gt; run without weights</span></div><div class="line">    );</div><div class="line"><span class="comment">// Initialise the scheduler</span></div><div class="line">scheduler_t scheduler(root.get() );</div><div class="line">scheduler.addAuditor&lt;RDFAnalysis::GraphDrawer&gt;(<span class="stringliteral">&quot;graph.dot&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Define new variables</span></div><div class="line"><span class="comment">// m_ee requires two electrons</span></div><div class="line">scheduler.registerVariable(<span class="stringliteral">&quot;m_ee&quot;</span>, <span class="stringliteral">&quot;(Electrons.at(0) + Electrons.at(1)).M()&quot;</span>, {<span class="stringliteral">&quot;N_ELE_2&quot;</span>});</div><div class="line"><span class="comment">// m_mumu requires two muons</span></div><div class="line">scheduler.registerVariable(<span class="stringliteral">&quot;m_mumu&quot;</span>, <span class="stringliteral">&quot;(Muons.at(0) + Muons.at(1)).M()&quot;</span>, {<span class="stringliteral">&quot;N_MU_2&quot;</span>});</div><div class="line"></div><div class="line"><span class="comment">// Define new filters</span></div><div class="line">scheduler.registerFilter(<span class="stringliteral">&quot;Photons.size() == 1&quot;</span>, <span class="stringliteral">&quot;N_GAM_1&quot;</span>, <span class="stringliteral">&quot;Exactly one photon&quot;</span>);</div><div class="line">scheduler.registerFilter(<span class="stringliteral">&quot;Electrons.size() == 2&quot;</span>, <span class="stringliteral">&quot;N_ELE_2&quot;</span>, <span class="stringliteral">&quot;Exactly two electrons&quot;</span>);</div><div class="line">scheduler.registerFilter(<span class="stringliteral">&quot;Muons.size() == 2&quot;</span>, <span class="stringliteral">&quot;N_MU_2&quot;</span>, <span class="stringliteral">&quot;Exactly two muons&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Define new fills</span></div><div class="line">scheduler.registerFill(TH1F(<span class="stringliteral">&quot;m_ee&quot;</span>, <span class="stringliteral">&quot;;m_{ee} [GeV]&quot;</span>, 50, 50, 100), {<span class="stringliteral">&quot;m_ee&quot;</span>});</div><div class="line">scheduler.registerFill(TH1F(<span class="stringliteral">&quot;m_mumu&quot;</span>, <span class="stringliteral">&quot;;m_{#mu#mu} [GeV]&quot;</span>, 50, 50, 100), {<span class="stringliteral">&quot;m_mumu&quot;</span>});</div><div class="line"></div><div class="line"><span class="comment">// Define the regions</span></div><div class="line"><span class="keyword">using</span> RegionDef = scheduler_t::RegionDef;</div><div class="line">RegionDef&amp; electronRegion = scheduler.addRegion(<span class="stringliteral">&quot;Electron&quot;</span>, {<span class="stringliteral">&quot;N_GAM_1&quot;</span>, <span class="stringliteral">&quot;N_ELE_2&quot;</span>});</div><div class="line">electronRegion.addFill(<span class="stringliteral">&quot;m_ee&quot;</span>);</div><div class="line">RegionDef&amp; muonRegion = scheduler.addRegion(<span class="stringliteral">&quot;Muon&quot;</span>, {<span class="stringliteral">&quot;N_GAM_1&quot;</span>, <span class="stringliteral">&quot;N_MU_2&quot;</span>});</div><div class="line">muonRegion.addFill(<span class="stringliteral">&quot;m_mumu&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Schedule the graph</span></div><div class="line">scheduler.schedule();</div><div class="line"></div><div class="line"><a class="code" href="classRDFAnalysis_1_1OutputWriter.html">RDFAnalysis::OutputWriter&lt;node_t::detail_t&gt;</a> writer(<span class="stringliteral">&quot;output.root&quot;</span>);</div><div class="line">writer.addWriter&lt;<a class="code" href="classRDFAnalysis_1_1CutflowWriter.html">RDFAnalysis::CutflowWriter</a>&gt;();</div><div class="line">writer.addWriter&lt;<a class="code" href="classRDFAnalysis_1_1TObjectWriter.html">RDFAnalysis::TObjectWriter</a>&gt;();</div><div class="line">writer.<a class="code" href="classRDFAnalysis_1_1TObjectWriter.html#a44e8c142f6cf561f83af21872808a01a">write</a>(scheduler);</div></div><!-- fragment --><p>This will produce exactly the same graph as in the previous example.</p>
<h1><a class="anchor" id="Schedule_AdvancedExample"></a>
Advanced Example</h1>
<p>In order to demonstrate some of the more advanced concepts than those that have already been seen we now consider attempting to reconstruct a H&rarr;bb decay. We want to plot the kinematics of both b-jets (where they exist) as well as the mass of the bb pair - for all events as well as those with exactly two b-tagged jets.</p>
<p>Assuming an input dataset </p><div class="fragment"><div class="line">std::vector&lt;TLorentzVector&gt; Jets; <span class="comment">//&gt; The jet kinematics</span></div><div class="line">std::vector&lt;char&gt; IsBTagged; <span class="comment">//&gt; Whether or not an individual jet is b-tagged</span></div><div class="line">std::vector&lt;float&gt; BTagSF; <span class="comment">//&gt; The scale factor for each jet</span></div></div><!-- fragment --><p>In order to make calculating the scale factors easier we define a few extra functions </p><div class="fragment"><div class="line"><span class="comment">// Require at least N b-tagged jets and return whether or not it passed and the</span></div><div class="line"><span class="comment">// corresponding scale factor</span></div><div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> N&gt;</div><div class="line">  std::tuple&lt;bool, float&gt; requireAtLeast(</div><div class="line">      <span class="keyword">const</span> ROOT::VecOps::RVec&lt;char&gt;&amp; isBTagged,</div><div class="line">      <span class="keyword">const</span> ROOT::VecOps::RVec&lt;float&gt;&amp; btagSFs)</div><div class="line">{</div><div class="line">  <span class="comment">// Count until we reach N b-tagged jets</span></div><div class="line">  std::size_t count;</div><div class="line">  <span class="keywordtype">float</span> sf = 1;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t ii = 0; ii &lt; isBTagged.size(); ++ii) {</div><div class="line">    <span class="keywordflow">if</span> (isBtagged.at(ii) )</div><div class="line">      ++count;</div><div class="line">    sf *= btagSFs.at(ii);</div><div class="line">    <span class="keywordflow">if</span> (count == N)</div><div class="line">      <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> std::make_tuple(count == N, sf);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Require exactly N b-tagged jets and return whether or not it passed and the</span></div><div class="line"><span class="comment">// corresponding scale factor</span></div><div class="line"><span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> N&gt;</div><div class="line">  std::tuple&lt;bool, float&gt; requireExact(</div><div class="line">      <span class="keyword">const</span> ROOT::VecOps::RVec&lt;char&gt;&amp; isBTagged,</div><div class="line">      <span class="keyword">const</span> ROOT::VecOps::RVec&lt;float&gt;&amp; btagSFs)</div><div class="line">{</div><div class="line">  <span class="comment">// Count until we reach N b-tagged jets</span></div><div class="line">  std::size_t count;</div><div class="line">  <span class="keywordtype">float</span> sf = 1;</div><div class="line">  <span class="keywordflow">for</span> (std::size_t ii = 0; ii &lt; isBTagged.size(); ++ii) {</div><div class="line">    <span class="keywordflow">if</span> (isBtagged.at(ii) )</div><div class="line">      ++count;</div><div class="line">    sf *= btagSFs.at(ii);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> std::make_tuple(count == N, sf);</div><div class="line">}</div></div><!-- fragment --><p> Note that ROOT converts std::vectors to <a href="https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html">ROOT::VecOps::RVec</a>s internally.</p>
<p>Then inside the main function, define the variables and schedule the regions as before </p><div class="fragment"><div class="line"><span class="keyword">using</span> node_t = <a class="code" href="classRDFAnalysis_1_1Node.html">RDFAnalysis::Node&lt;CutflowDetail&gt;</a>;</div><div class="line"><span class="keyword">using</span> scheduler_t = <a class="code" href="classRDFAnalysis_1_1Scheduler.html">RDFAnalysis::Scheduler&lt;node_t::detail_t&gt;</a>;</div><div class="line"></div><div class="line">std::unique_ptr&lt;node_t&gt; root = node_t::createROOT(</div><div class="line">    inputDF, <span class="comment">//&gt; The input to this analysis</span></div><div class="line">    std::make_unique&lt;RDFAnalysis::DefaultBranchNamer&gt;({<span class="stringliteral">&quot;NOSYS&quot;</span>}), <span class="comment">//&gt; Systematics related</span></div><div class="line">    <span class="keyword">false</span> <span class="comment">//&gt; run without weights</span></div><div class="line">    );</div><div class="line"><span class="comment">// Initialise the scheduler</span></div><div class="line">scheduler_t scheduler(root.get() );</div><div class="line">scheduler.addAuditor&lt;RDFAnalysis::GraphDrawer&gt;(<span class="stringliteral">&quot;graph.dot&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Define the new variables</span></div><div class="line">scheduler.registerVariable(<span class="stringliteral">&quot;BJets&quot;</span>, <span class="stringliteral">&quot;Jets[IsBTagged]&quot;</span>); <span class="comment">//&gt; Only the jets that are b-tagged</span></div><div class="line">scheduler.registerVariable(<span class="stringliteral">&quot;BJet0&quot;</span>, <span class="stringliteral">&quot;BJets.at(0)&quot;</span>, {<span class="stringliteral">&quot;NB_GE_1&quot;</span>}); <span class="comment">//&gt; The leading b-jet kinematics</span></div><div class="line">scheduler.registerVariable(<span class="stringliteral">&quot;BJet1&quot;</span>, <span class="stringliteral">&quot;BJets.at(1)&quot;</span>, {<span class="stringliteral">&quot;NB_GE_2&quot;</span>}); <span class="comment">//&gt; The sub-leading b-jet kinematics</span></div><div class="line"><span class="comment">// Define a lambda that retrieves the pt, eta, phi and m from a TLorentzVector</span></div><div class="line"><span class="keyword">auto</span> extractPtEtaPhiM = [] (<span class="keyword">const</span> TLorentzVector&amp; v) {</div><div class="line">  <span class="keywordflow">return</span> std::make_tuple(v.Pt(), v.Eta(), TVector2::Phi_mpi_pi(v.Phi()), v.M() );</div><div class="line">}</div><div class="line">scheduler.registerVariables&lt;4&gt;(</div><div class="line">    {<span class="stringliteral">&quot;BJet0Pt&quot;</span>, <span class="stringliteral">&quot;BJet0Eta&quot;</span>, <span class="stringliteral">&quot;BJet0Phi&quot;</span>, <span class="stringliteral">&quot;BJet0Mass&quot;</span>},</div><div class="line">    extractPtEtaPhiM, {<span class="stringliteral">&quot;BJet0&quot;</span>});</div><div class="line">scheduler.registerVariables&lt;4&gt;(</div><div class="line">    {<span class="stringliteral">&quot;BJet1Pt&quot;</span>, <span class="stringliteral">&quot;BJet1Eta&quot;</span>, <span class="stringliteral">&quot;BJet1Phi&quot;</span>, <span class="stringliteral">&quot;BJet1Mass&quot;</span>},</div><div class="line">    extractPtEtaPhiM, {<span class="stringliteral">&quot;BJet1&quot;</span>});</div><div class="line">scheduler.registerVariable(<span class="stringliteral">&quot;m_bb&quot;</span>, <span class="stringliteral">&quot;(BJet0+BJet1).M()&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Define the filters</span></div><div class="line">scheduler.registerFilter(<span class="stringliteral">&quot;NB_GE_1&quot;</span>, requireAtLeast&lt;1&gt;, {<span class="stringliteral">&quot;IsBTagged&quot;</span>, <span class="stringliteral">&quot;BTagSF&quot;</span>});</div><div class="line">scheduler.registerFilter(<span class="stringliteral">&quot;NB_GE_2&quot;</span>, requireAtLeast&lt;2&gt;, {<span class="stringliteral">&quot;IsBTagged&quot;</span>, <span class="stringliteral">&quot;BTagSF&quot;</span>});</div><div class="line">scheduler.registerFilter(<span class="stringliteral">&quot;NB_EQ_2&quot;</span>, requireExact&lt;2&gt;, {<span class="stringliteral">&quot;IsBTagged&quot;</span>, <span class="stringliteral">&quot;BTagSF&quot;</span>});</div><div class="line"><span class="comment">// Record the filter relations</span></div><div class="line">scheduler.filterSatisfies(<span class="stringliteral">&quot;NB_GE_2&quot;</span>, {<span class="stringliteral">&quot;NB_GE_1&quot;</span>});</div><div class="line">scheduler.filterSatisfies(<span class="stringliteral">&quot;NB_EQ_2&quot;</span>, {<span class="stringliteral">&quot;NB_GE_2&quot;</span>});</div><div class="line"></div><div class="line"><span class="comment">// Define the fills</span></div><div class="line">scheduler.registerFill(TH1F(<span class="stringliteral">&quot;BJet0Pt&quot;</span>, <span class="stringliteral">&quot;;p_{T} (b-jet_{0}) [GeV]&quot;</span>, 100, 0, 500), {<span class="stringliteral">&quot;BJet0Pt&quot;</span>});</div><div class="line">scheduler.registerFill(TH1F(<span class="stringliteral">&quot;BJet1Pt&quot;</span>, <span class="stringliteral">&quot;;p_{T} (b-jet_{1}) [GeV]&quot;</span>, 100, 0, 500), {<span class="stringliteral">&quot;BJet1Pt&quot;</span>});</div><div class="line">scheduler.registerFill(TH1F(<span class="stringliteral">&quot;BJet0Eta&quot;</span>, <span class="stringliteral">&quot;#eta (b-jet_{0})&quot;</span>, 10, -2.5, 2.5), {<span class="stringliteral">&quot;BJet0Eta&quot;</span>});</div><div class="line">scheduler.registerFill(TH1F(<span class="stringliteral">&quot;BJet1Eta&quot;</span>, <span class="stringliteral">&quot;#eta (b-jet_{1})&quot;</span>, 10, -2.5, 2.5), {<span class="stringliteral">&quot;BJet1Eta&quot;</span>});</div><div class="line">scheduler.registerFill(TH1F(<span class="stringliteral">&quot;BJet0Phi&quot;</span>, <span class="stringliteral">&quot;#phi (b-jet_{0})&quot;</span>, 70, -3.5, 3.5), {<span class="stringliteral">&quot;BJet0Phi&quot;</span>});</div><div class="line">scheduler.registerFill(TH1F(<span class="stringliteral">&quot;BJet1Phi&quot;</span>, <span class="stringliteral">&quot;#phi (b-jet_{1})&quot;</span>, 70, -3.5, 3.5), {<span class="stringliteral">&quot;BJet1Phi&quot;</span>});</div><div class="line">scheduler.registerFill(TH1F(<span class="stringliteral">&quot;m_bb&quot;</span>, <span class="stringliteral">&quot;;m_{bb}&quot;</span>, 75, 0, 150), {<span class="stringliteral">&quot;m_bb&quot;</span>});</div><div class="line"></div><div class="line"><span class="comment">// Define the regions</span></div><div class="line"><span class="keyword">using</span> RegionDef = scheduler_t::RegionDef;</div><div class="line">RegionDef&amp; root = scheduler.addRegion(<span class="stringliteral">&quot;ROOT&quot;</span>, {});</div><div class="line">RegionDef&amp; signalRegion = scheduler.addRegion(<span class="stringliteral">&quot;SignalRegion&quot;</span>, {<span class="stringliteral">&quot;NB_EQ_2&quot;</span>});</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> std::string&amp; h : {<span class="stringliteral">&quot;BJet0Pt&quot;</span>, <span class="stringliteral">&quot;BJet1Pt&quot;</span>, <span class="stringliteral">&quot;BJet0Eta&quot;</span>, <span class="stringliteral">&quot;BJet1Eta&quot;</span>, <span class="stringliteral">&quot;BJet0Phi&quot;</span>, <span class="stringliteral">&quot;BJet1Phi&quot;</span>, <span class="stringliteral">&quot;m_bb&quot;</span>}) {</div><div class="line">  root.addFill(h);</div><div class="line">  signalRegion.addFill(h);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Schedule the graph</span></div><div class="line">scheduler.schedule();</div><div class="line"></div><div class="line"><a class="code" href="classRDFAnalysis_1_1OutputWriter.html">RDFAnalysis::OutputWriter&lt;node_t::detail_t&gt;</a> writer(<span class="stringliteral">&quot;output.root&quot;</span>);</div><div class="line">writer.addWriter&lt;<a class="code" href="classRDFAnalysis_1_1CutflowWriter.html">RDFAnalysis::CutflowWriter</a>&gt;();</div><div class="line">writer.addWriter&lt;<a class="code" href="classRDFAnalysis_1_1TObjectWriter.html">RDFAnalysis::TObjectWriter</a>&gt;();</div><div class="line">writer.<a class="code" href="classRDFAnalysis_1_1TObjectWriter.html#a44e8c142f6cf561f83af21872808a01a">write</a>(scheduler);</div></div><!-- fragment --><p>This produces the following computational graph. </p><div class="image">
<img src="example_advanced_sel.png" alt="example_advanced_sel.png"/>
</div>
<h1><a class="anchor" id="Scheduler_Notes"></a>
Important notes and caveats</h1>
<p>When using filters that involving scale factors (and therefore increase event-level weights) you need to be careful. If, in the advanced example, we had not provided the <code>filterSatisfies</code> relations then to produce the signal region m_bb distribution all 3 filters ("NB_GE_1", "NB_GE_2" and "NB_EQ_2") would have been applied and scale factors up to and including the first b-jet would have been triple-counted and scale factors from there to the second b-jet double counted! However, properly specifying these satisfaction relations fixes this problem.</p>
<p>Another thing to watch out for is the order in which actions are registered with the scheduler. <b>With one exception</b> actions can be declared in any order, that exception being where new (i.e. not present in the input dataset) variables are used in string expressions. <a class="el" href="classRDFAnalysis_1_1ScheduleNamer.html">A specialised IBranchNamer class</a> is used to extract variables from string expressions, but this only knows about variables after they have been registered. This means that it's always better to register variables <em>first</em>, and to be careful with the ordering of those variables. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jun 21 2019 08:10:28 for RDFAnalysis by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
