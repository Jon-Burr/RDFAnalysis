#ifndef RDFAnalysis_Node_ICC
#define RDFAnalysis_Node_ICC

namespace RDFAnalysis {
  template <typename F>
    std::enable_if_t<!std::is_convertible<F, std::string>{}, Node&> Node::Define(
        const std::string& name,
        F f,
        const ColumnNames_t& columns)
    {
      // First, work out which systematics this affects
      std::set<std::string> affecting = m_namer->systematicsAffecting(columns);
      // Make sure that we at least affect the nominal
      if (affecting.size() == 0)
        affecting.insert(m_namer->nominalName() );

      // For each of our RNodes, update it to be the one with the new variable
      // defined on it.
      for (auto& rnode : m_rnodes) {
        // Remove this systematic from consideration
        affecting.erase(rnode.first);
        rnode.second = rnode.second.Define(
            m_namer->createBranch(name, rnode.first, true),
            f,
            m_namer->nameBranches(columns, rnode.first) );
      }
      // Add any left over to the nominal
      RNode& nominal = m_rnodes.at(m_namer->nominalName());
      for (const std::string& syst : affecting)
        nominal = nominal.Define(
            m_namer->createBranch(name, syst, false),
            f,
            m_namer->nameBranches(columns, syst) );
      return *this;
    }

  template <typename F>
    std::enable_if_t<!std::is_convertible<F, std::string>{},
    std::shared_ptr<Node>> Node::Filter(
        F f,
        const ColumnNames_t& columns,
        const std::string& name,
        const std::string& cutflowName)
    {
      // Make sure that there isn't already a node with this name
      for (const std::shared_ptr<Node>& child : m_children)
        if (child->name() == name)
          throw std::runtime_error(
              "Attempting to create child '" + name + "' but this node " + 
              "already has a node with that name!");

      // First, work out which systematics this affects
      std::set<std::string> affecting = m_namer->systematicsAffecting(columns);
      // Make sure that we at least affect the nominal
      if (affecting.size() == 0)
        affecting.insert(m_namer->nominalName() );
      
      std::map<std::string, RNode> childRNodes;
      for (auto& rnodePair : m_rnodes) {
        childRNodes.insert(std::make_pair(
              rnodePair.first, 
              rnodePair.second.Filter(
                f,
                m_namer->nameBranches(columns, rnodePair.first),
                cutflowName) ) );
        affecting.erase(rnodePair.first);
      }

      RNode& nominalNode = m_rnodes.at(m_namer->nominalName() );
      for (const std::string& syst : affecting)
        childRNodes.insert(std::make_pair(
              syst,
              nominalNode.Filter(
                f,
                m_namer->nameBranches(columns, syst),
                cutflowName) ) );
      // Create the new child and add it
      // Note - use 'new' rather than make_unique as this is a protected
      // constructor
      std::shared_ptr<Node> child(new Node(
            *this, std::move(childRNodes),  name, cutflowName) );
      m_children.push_back(child);
      return child;
    }

  template <typename F>
    std::enable_if_t<!std::is_convertible<F, std::string>{},
    std::shared_ptr<Node>> Node::setWeight(
        F f,
        const ColumnNames_t& columns, 
        bool multiplicative)
    {
      if (multiplicative && m_parent && !m_parent->getWeight().empty() ) {
        // Adapt f to include the parent weight and call this function with the
        // new functor and multiplicative set to false
        ColumnNames_t newColumns = columns;
        newColumns.push_back(m_parent->getWeight() );
        return setWeight(
            [f] (auto&&... args, const double& parentWeight) {
              return parentWeight * f(std::forward<decltype(args)>(args)...);
            },
            newColumns,
            false);
      }
      else {
        m_weight = nameWeight();
        // Define the new weight
        Define(m_weight, f, columns);
        // Reset the weighted node statistics
        setupWeightedStatistics();
      }
      return shared_from_this();
    }

  template <typename T>
    SysResultPtr<T> Node::Fill(
        const T& model,
        const ColumnNames_t& columns)
    {
      // Create the result pointer
      SysResultPtr<T> result(m_namer->nominalName() );
      // Which systematics do we care about?
      std::set<std::string> affecting = m_namer->systematicsAffecting(columns);

      // Create the object from all of our rnodes first, erasing systematics as
      // we go
      for (auto& rnodePair : m_rnodes) {
        result.addResult(
            rnodePair.first,
            rnodePair.second.Fill(
              T(model),
              m_namer->nameBranches(columns) ) );
        affecting.erase(rnodePair.first);
      }

      // TODO - make this extraction of the right branch names from the vector
      // part of the namer class!

      RNode& nominalNode = m_rnodes.at(m_namer->nominalName() );
      // For all the remaining systematics make them from the nominal
      for (const std::string& syst : affecting)
        result.addResult(
            syst,
            nominalNode.Fill(
              T(model),
              m_namer->nameBranches(columns) ) );
      // We won't write the contents of anonymous nodes so don't even keep them
      // here
      if (!isAnonymous() )
        m_objects.push_back(result);
      return result;      
    }
}

#endif //> !RDFAnalysis_Node_ICC
