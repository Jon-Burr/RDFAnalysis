#ifndef RDFAnalysis_Node_ICC
#define RDFAnalysis_Node_ICC

namespace RDFAnalysis {
  template <typename F>
    std::enable_if_t<!std::is_convertible<F, std::string>{}, Node&> Node::Define(
        const std::string& name,
        F f,
        const ColumnNames_t& columns)
    {
      // First, work out which systematics this affects
      std::set<std::string> affecting = m_namer->systematicsAffecting(columns);
      // Make sure that we at least affect the nominal
      if (affecting.size() == 0)
        affecting.insert(m_namer->nominalName() );

      // For each of our RNodes, update it to be the one with the new variable
      // defined on it.
      for (auto& rnode : m_rnodes) {
        // Remove this systematic from consideration
        affecting.erase(rnode.first);
        std::vector<std::string> newColumns;
        newColumns.reserve(columns.size() );
        for (const std::string& branch : columns)
          newColumns.push_back(m_namer->nameBranch(branch, rnode.first) );
        rnode.second = rnode.second.Define(
            m_namer->nameBranch(name, rnode.first, true, true),
            f, newColumns);
      }
      // Add any left over to the nominal
      RNode& nominal = m_rnodes.at(m_namer->nominalName());
      for (const std::string& syst : affecting) {
        std::vector<std::string> newColumns;
        newColumns.reserve(columns.size() );
        for (const std::string& branch : columns)
          newColumns.push_back(m_namer->nameBranch(branch, syst) );
        nominal = nominal.Define(
            m_namer->nameBranch(name, syst, true, false),
            f, newColumns);
      }
      return *this;
    }

  template <typename F>
    std::enable_if_t<!std::is_convertible<F, std::string>{},
    std::shared_ptr<Node>> Node::Filter(
        F f,
        const ColumnNames_t& columns,
        const std::string& name,
        const std::string& cutflowName)
    {
      // If this is going to make an anonymous node, make sure there aren't
      // other children
      if (name.empty() && m_children.size() > 0)
        throw std::runtime_error(
            "Attempting to define an anonymous node on a node that already "
            "has children. This is not allowed.");
      // First, work out which systematics this affects
      std::set<std::string> affecting = m_namer->systematicsAffecting(columns);
      // Make sure that we at least affect the nominal
      if (affecting.size() == 0)
        affecting.insert(m_namer->nominalName() );

      // Make a child node
      // Note - use 'new' rather than make_unique as this is a protected
      // constructor
      std::shared_ptr<Node> child(new Node(*this, name, cutflowName) );
      m_children.push_back(child);

      // Apply the filters to the child node
      for (auto& rnodePair : child->m_rnodes) {
        std::vector<std::string> newColumns;
        newColumns.reserve(columns.size() );
        for (const std::string& branch : columns)
          newColumns.push_back(m_namer->nameBranch(branch, rnodePair.first) );
        rnodePair.second = rnodePair.second.Filter(f, newColumns, cutflowName);
        affecting.erase(rnodePair.first);
      }

      RNode& nominalNode = m_rnodes.at(m_namer->nominalName() );
      // Make new child rnodes for every remaining systematic
      for (const std::string& syst : affecting) {
        std::vector<std::string> newColumns;
        newColumns.reserve(columns.size() );
        for (const std::string& branch : columns)
          newColumns.push_back(m_namer->nameBranch(branch, syst) );
        // Create the new filters from this nodes nominal rnode.
        child->m_rnodes.insert(std::make_pair(
              syst, nominalNode.Filter(f, newColumns, cutflowName) ) );
      }
      return child;
    }

  template <typename T>
    SysResultPtr<T> Node::Fill(
        const T& model,
        const ColumnNames_t& columns)
    {
      // Create the result pointer
      SysResultPtr<T> result(m_namer->nominalName() );
      // Which systematics do we care about?
      std::set<std::string> affecting = m_namer->systematicsAffecting(columns);

      // Create the object from all of our rnodes first, erasing systematics as
      // we go
      for (auto& rnodePair : m_rnodes) {
        std::vector<std::string> newColumns;
        newColumns.reserve(columns.size() );
        for (const std::string& branch : columns)
          newColumns.push_back(m_namer->nameBranch(branch, rnodePair.first) );
        result.addResult(
            rnodePair.first,
            rnodePair.second.Fill(T(model), newColumns) );
        affecting.erase(rnodePair.first);
      }

      // TODO - make this extraction of the right branch names from the vector
      // part of the namer class!

      RNode& nominalNode = m_rnodes.at(m_namer->nominalName() );
      // For all the remaining systematics make them from the nominal
      for (const std::string& syst : affecting) {
        std::vector<std::string> newColumns;
        newColumns.reserve(columns.size() );
        for (const std::string& branch : columns)
          newColumns.push_back(m_namer->nameBranch(branch, syst) );
        result.addResult(
            syst,
            nominalNode.Fill(T(model), newColumns) );
      }
      // We won't write the contents of anonymous nodes so don't even keep them
      // here
      if (!isAnonymous() )
        m_objects.push_back(result);
      return result;      
    }
}

#endif //> !RDFAnalysis_Node_ICC
