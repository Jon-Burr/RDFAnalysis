#ifndef RDFAnalysis_Node_ICC
#define RDFAnalysis_Node_ICC

#include <utility>
#include <tuple>
#include <iostream>

namespace RDFAnalysis {
  template <typename Detail> template <typename T, typename... TrArgs, typename... Args>
    std::map<std::string, T> Node<Detail>::Act(
        std::function<T(RNode&, TrArgs...)> f,
        const ColumnNames_t& columns,
        Args&&... args)
    {
      // Prepare the output
      std::map<std::string, T> result;
      // First work out which systematics affect this action
      std::set<std::string> affecting = m_namer->systematicsAffecting(columns);

      // For each existing RNode apply the action to it
      for (auto& rnodePair : m_rnodes) {
        // Remove this systematic from future consideration
        affecting.erase(rnodePair.first);
        result.insert(std::make_pair(
              rnodePair.first,
              f(rnodePair.second,
                sysVarTranslate(
                  std::forward<Args>(args),
                  *m_namer,
                  rnodePair.first)...) ) );
      }

      // Now iterate over the remaining systematics and add the definition to
      // the nominal
      RNode& nominal = m_rnodes.at(m_namer->nominalName() );
      for (const std::string& syst : affecting)
        result.insert(std::make_pair(
              syst,
              f(nominal,
                sysVarTranslate(
                  std::forward<Args>(args),
                  *m_namer,
                  syst)...) ) );

      return result;
    }

  template <typename Detail> template <typename T, typename... TrArgs, typename... Args>
    std::map<std::string, T> Node<Detail>::Act(
        T (RNode::*f)(TrArgs&&...),
        const ColumnNames_t& columns,
        Args&&... args)
    {
      // Prepare the output
      std::map<std::string, T> result;
      // First work out which systematics affect this action
      std::set<std::string> affecting = m_namer->systematicsAffecting(columns);

      // For each existing RNode apply the action to it
      for (auto& rnodePair : m_rnodes) {
        // Remove this systematic from future consideration
        affecting.erase(rnodePair.first);
        result.insert(std::make_pair(
              (rnodePair.first.*f)(sysVarTranslate(
                  std::forward<Args>(args),
                  *m_namer,
                  rnodePair.first)... ) ) );
      }

      // Now iterate over the remaining systematics and add the definition to
      // the nominal
      RNode& nominal = m_rnodes.at(m_namer->nominalName() );
      for (const std::string& syst : affecting)
        result.insert(std::make_pair(
              syst,
              (nominal.*f)(sysVarTranslate(
                  std::forward<Args>(args),
                  *m_namer,
                  syst)...) ) );

      return result;
    }

  template <typename Detail> template <typename F>
    enable_ifn_string_t<F, std::shared_ptr<Node<Detail>>> Node<Detail>::Define(
        const std::string& name,
        F f,
        const ColumnNames_t& columns)
    {
      // We don't actually use the output of the action so we don't store it.
      // However we need there to be a return value for the lambda.
      // Note that this action updates the node passed in.
      Act([] (RNode& rnode, const std::string& name, F f, const ColumnNames_t& columns) {
          return rnode = rnode.Define(name, f, columns); },
          columns,
          SysVarNewBranch(name),
          f,
          SysVarBranchVector(columns) );
      return this->shared_from_this();
    }


  template <typename Detail>
    std::shared_ptr<Node<Detail>> Node<Detail>::Define(
        const std::string& name,
        const std::string& expression)
    {
      auto expanded = m_namer->expandExpression(expression);
      return Define(name, expanded.first, expanded.second);
    }

  template <typename Detail>
    std::shared_ptr<Node<Detail>> Node<Detail>::Define(
        const std::string& name,
        const std::string& expression,
        const ColumnNames_t& columns)
    {
      // We don't actually use the output of the action so we don't store it.
      // However we need there to be a return value for the lambda.
      // Note that this action updates the node passed in.
      Act([] (RNode& rnode, const std::string& name, const std::string& expression) {
          return rnode = rnode.Define(name, expression); },
          columns,
          SysVarNewBranch(name),
          SysVarStringExpression(expression, columns) );
      return this->shared_from_this();
    }

  template <typename Detail> template <typename F>
    enable_ifn_string_t<F, std::shared_ptr<Node<Detail>>> Node<Detail>::Filter(
        F f,
        const ColumnNames_t& columns,
        const std::string& name,
        const std::string& cutflowName)
    {
      // Make sure that there isn't already a node with this name
      for (const std::shared_ptr<Node>& child : m_children)
        if (child->name() == name)
          throw std::runtime_error(
              "Attempting to create child '" + name + "' but this node " + 
              "already has a node with that name!");

      std::map<std::string, RNode> childRNodes = Act(
          [] (RNode& rnode, F f, const ColumnNames_t& columns, const std::string& cutflowName) -> RNode {
          return rnode.Filter(f, columns, cutflowName); },
          columns,
          f,
          SysVarBranchVector(columns),
          cutflowName);
      std::shared_ptr<Node> child(new Node(
            *this, std::move(childRNodes),  name, cutflowName) );
      m_children.push_back(child);
      return child;
    }

  template <typename Detail>
    std::shared_ptr<Node<Detail>> Node<Detail>::Filter(
        const std::string& expression,
        const std::string& name,
        const std::string& cutflowName)
    {
      auto expanded = m_namer->expandExpression(expression);
      return Filter(expanded.first, expanded.second, name, cutflowName);
    }

  template <typename Detail>
    std::shared_ptr<Node<Detail>> Node<Detail>::Filter(
        const std::string& expression,
        const ColumnNames_t& columns,
        const std::string& name,
        const std::string& cutflowName)
    {
      // Make sure that there isn't already a node with this name
      for (const std::shared_ptr<Node>& child : m_children)
        if (child->name() == name)
          throw std::runtime_error(
              "Attempting to create child '" + name + "' but this node " + 
              "already has a node with that name!");

      std::map<std::string, RNode> childRNodes = Act(
          [] (RNode& rnode, const std::string& expression, const std::string& cutflowName) -> RNode{
          return rnode.Filter(expression, cutflowName); },
          columns,
          SysVarStringExpression(expression, columns),
          cutflowName);
      std::shared_ptr<Node> child(new Node(
            *this, std::move(childRNodes),  name, cutflowName) );
      m_children.push_back(child);
      return child;
    }

  template <typename Detail> template <typename F>
    enable_ifn_string_t<F, std::shared_ptr<Node<Detail>>> Node<Detail>::setWeight(
        F f,
        const ColumnNames_t& columns, 
        bool multiplicative)
    {
      if (multiplicative && m_parent && !m_parent->getWeight().empty() ) {
        // Adapt f to include the parent weight and call this function with the
        // new functor and multiplicative set to false
        ColumnNames_t newColumns = columns;
        newColumns.push_back(m_parent->getWeight() );
        return setWeight(
            [f] (auto&&... args, const double& parentWeight) {
              return parentWeight * f(std::forward<decltype(args)>(args)...);
            },
            newColumns,
            false);
      }
      else {
        m_weight = nameWeight();
        // Define the new weight
        Define(m_weight, f, columns);
        // Reset the weighted node statistics
        setupWeightedStatistics();
      }
      return this->shared_from_this();
    }

  template <typename Detail>
    std::shared_ptr<Node<Detail>> Node<Detail>::setWeight(
        const std::string& expression,
        bool multiplicative)
    {
      if (multiplicative && m_parent && !m_parent->getWeight().empty() ) {
        // Adapt the expression to include the parent weight and then call this
        // function again with the new expression and multiplicative set to false
        return setWeight("("+expression+") * " + m_parent->getWeight(), false);
      }
      else if (m_namer->exists(expression) ) {
        // For this version only, if the new weight is already a column, no need
        // to recalculated it...
        m_weight = expression;
        setupWeightedStatistics();
      }
      else {
        m_weight = nameWeight();
        Define(m_weight, expression);
        // Reset the weighted node statistics
        setupWeightedStatistics();
      }
      return this->shared_from_this();
    }

  template <typename Detail>
    std::shared_ptr<Node<Detail>> Node<Detail>::setWeight(
        const std::string& expression,
        const ColumnNames_t& columns,
        bool multiplicative)
    {
      if (multiplicative && m_parent && !m_parent->getWeight().empty() ) {
        // Adapt the expression to include the parent weight and then call this
        // function again with the new expression and multiplicative set to false
        ColumnNames_t newColumns = columns;
        newColumns.push_back(m_parent->getWeight() );
        return setWeight(
            "("+expression+") * {" + std::to_string(columns.size() ) + "}",
            newColumns,
            false);
      }
      else {
        m_weight = nameWeight();
        Define(m_weight, expression, columns);
        // Reset the weighted node statistics
        setupWeightedStatistics();
      }
      return this->shared_from_this();
    }

  template <typename Detail> template <typename T>
    SysResultPtr<T> Node<Detail>::Fill(
        const T& model,
        const ColumnNames_t& columns)
    {
      // Create the result pointer
      SysResultPtr<T> result(m_namer->nominalName() );
      // Get the action's results
      auto actOutMap = Act(
          [] (RNode& rnode, T&& t, const ColumnNames_t& col) { return rnode.Fill(T(t), col); },
          columns,
          T(model),
          SysVarBranchVector(columns) );
      // Load them into the output
      for (const auto& actPair : actOutMap)
        result.addResult(actPair.first, actPair.second);
      // We won't write the contents of anonymous nodes so don't even keep them
      // here
      if (!isAnonymous() )
        m_objects.push_back(result);
      return result;      
    }

  template <typename Detail>
    Node<Detail>::Node(
        const RNode& rnode,
        std::unique_ptr<IBranchNamer>&& namer,
        const std::string& name,
        const std::string& cutflowName) :
      m_rnodes({{namer->nominalName(), rnode}}),
      m_namer(std::move(namer) ),
      m_name(name),
      m_cutflowName(cutflowName),
      m_rootRNode(&m_rnodes.at(m_namer->nominalName() ) ),
      m_stats(m_namer->nominalName() ),
      m_weightedStats(m_namer->nominalName() ),
      m_detail(*this)
    {
      m_namer->readBranchList(m_rnodes);
      m_stats.addResult(
          m_namer->nominalName(), 
          m_rnodes.at(m_namer->nominalName() ).Count() );
    }

  template <typename Detail>
    Node<Detail>::Node(
        Node& parent,
        std::map<std::string, RNode>&& rnodes,
        const std::string& name,
        const std::string& cutflowName) :
      m_parent(&parent),
      m_rnodes(std::move(rnodes) ),
      m_namer(parent.m_namer->copy() ),
      m_name(name),
      m_cutflowName(cutflowName),
      m_rootRNode(parent.m_rootRNode),
      m_stats(m_namer->nominalName() ),
      m_weightedStats(m_namer->nominalName() ),
      m_weight(parent.getWeight() ),
      m_detail(*this)
    {
      for (auto& nodePair : m_rnodes) {
        m_stats.addResult(nodePair.first, nodePair.second.Count() );
      }
      if (!m_weight.empty() )
        setupWeightedStatistics();
    }

  template <typename Detail>
    std::string Node<Detail>::nameWeight()
    {
      // Construct the name of the node by hashing the pointer
      return "_NodeWeight_"+std::to_string(std::hash<Node*>()(this) )+"_";
    }

  template <typename Detail>
    void Node<Detail>::setupWeightedStatistics()
    {
      // Clear out anything that was already there.
      m_weightedStats.reset();
      // Work out which systematics we care about
      std::set<std::string> affecting = m_namer->systematicsAffecting(m_weight);

      auto aggrFunc = [] (const std::pair<float, float>& lhs, float rhs)
      { return std::make_pair(lhs.first + rhs, lhs.second + rhs*rhs); };
      auto mergeFunc =
        [] (const std::pair<float, float>& lhs, const std::pair<float, float>& rhs)
      { return std::make_pair(lhs.first+rhs.first, lhs.second+rhs.second); };

      for (auto& rnodePair : m_rnodes) {
        m_weightedStats.addResult(
            rnodePair.first,
            rnodePair.second.Aggregate(
              aggrFunc,
              mergeFunc,
              m_namer->nameBranch(m_weight, rnodePair.first) ) );
        affecting.erase(rnodePair.first);
      }
      RNode& nominalNode = m_rnodes.at(m_namer->nominalName() );
      // For all the remaining systematics make them from the nominal
      for (const std::string& syst : affecting)
        m_weightedStats.addResult(
            syst,
            nominalNode.Aggregate(
              aggrFunc,
              mergeFunc,
              m_namer->nameBranch(m_weight, syst) ) );
    }
}

#endif //> !RDFAnalysis_Node_ICC
